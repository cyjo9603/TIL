# 문자열

자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열에 저장된다.

자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16을 따른다.

## 따옴표

```jsx
const single = '작은 따옴표';
const double = "큰 따옴표";
const backticks = `백틱`;
```

문자열은 작은 따옴표나 큰 따옴표, 백틱으로 감쌀 수 있다.

작은 따옴표와 큰 따옴표는 기능상 큰 차이가 없지만 백틱은 다르다. 표현식을 ${...}로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 삽입할 수 있다. 이런 방식을 템플릿 리터럴이라 한다.

```jsx
const guestList = `손님:
	* John
	* Pete
	* Mary
`;
```

백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있다.

작은 따옴표나 큰 따옴표로 문자열을 표현하는 방식은 자바스크립트가 만들어졌을 때부터 있었다. 이때 문자열을 여러 줄에 작성할 생각조차 못 했던 시기였는데 백틱은 그 이후에 등장한 문법이기 때문에 따옴표보다 다양한 기능을 제공한다.

```jsx
const print = (str) => {
  console.log(str);
};

print`Hello
World`; // [ 'Hello\n  World' ]
```

백틱은 템플릿 함수에도 사용된다. 다음 함수와 같이 첫 번째 백틱 바로 앞에 함수 이름을 써주면 이 함수는 백틱 안의 문자열 조각이나 표현식 평과 결과를 배열로 담은 인수를 받아 호출한다.

이런 기능을 태그드 템플릿이라 부르는데, 태그드 템플릿을 사용하면 사용자 지정 템플릿에 맞는 문자열을 쉽게 만들 수 있다.

## 특수 기호

모든 특수 문자는 '이스케이프 문자(escape character)'라고 불리는 역슬래시 `\`로 시작한다.

[특수 문자 목록](https://www.notion.so/03491a4105d44585a8403d224eaabde3)

예시)

```jsx
console.log( "\u00A9" ); // ©
console.log( "\u{20331}" ); // 佫, 중국어(긴 유니코드)
console.log( "\u{1F60D}" ); // 😍, 웃는 얼굴 기호(긴 유니코드)
```

역슬래시 `\`는 문자열을 정확하게 읽기 위한 용도로 만들어졌으므로 `\`는 제 역할이 끝나면 사라진다. 메모리에 저장되는 문자열엔 `\`가 없다. (백틱 x)

## 문자열의 길이

문자열의 `length` 프로퍼티엔 문자열의 길이가 저장된다.

각 특수문자는 문자 하나로 취급되기 때문에 길이 1만큼을 차지한다.

## 특정 글자에 접근하기

문자열 내 특정 위치에 접근하려면 대괄호`[]`를 이요하고나 `charAt`라는 메서드를 호출해 접근할 수 있다.

```jsx
const str = 'Hello';

console.log(str[0]); // 'H'
console.log(str.charAt(1)); // 'e'
```

근래에는 대괄호를 이용하는 방식을 사용한다. `charAt`은 하위 호환성을 위해 남아있는 메서드라고 생각하면 된다.

두 방식의 차이는 반환할 글자가 없을 때 드러난다. 접근하려는 위치에 글자가 없는 경우 `[]`는 `undefined`를, `charAt`은 빈 문자열을 반환한다.

```jsx
for (let char of 'Hello') {
	console.log(char); // H,e,l,l,o
}
```

`for...of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복작업을 할 수 있다.

## 문자열의 불변성

문자열은 수정할 수 없다. 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

```jsx
let str = 'Hi';

str[0] = 'h';

console.log(str); // 'Hi'
```

문자열의 인덱스에 특정 문자열을 할당해도 변하지 않는다.

이런 문제를 피하려면 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 `str`에 할당하면 된다.

## 문자열 원형과 String 객체의 차이

자바스크립트는 `String` 객체와 원형의 문자열을 다르게 취급한다.

생성자 없이 `String`을 호출하여 반환된 문자열은 원형 문자열(primitive strings)이다. 

```jsx
const s1 = '2 + 2';
const s2 = new String('2 + 2');

console.log(eval(s1)); // 4
console.log(eval(s2)); // [String: '2 + 2']
console.log(eval(s2.valueOf())); // 4
```

문자열 원형과 `String` 객체는 `eval()`을 사용할 때 다른 결과를 제공한다. `eval`에 전달되는 문자열 원형들은 소스 코드 취급을 받는다. `String` 오브젝트들은 다른 모든 오브젝트들을 마찬가지로 취급하여 오브젝트를 반환한다. 

`String` 객체는 `valueOf()` 메서드를 사용해 원형에 대응하도록 전환할 수 있다.

`eval()`의 사용은 많은 문제점이 존재하기 때문에 되도록이면 사용을 피하는 것이 좋다.

## 문자열 심화

### 서로게이트 쌍

자주 사용되는 글자들은 모두 2바이트 코드를 가지고 있다. 유럽권 언어에서 사용되는 글자, 숫자 , 상형 문자 대다수는 2바이트 표현 체계를 사용한다.

그런데 2바이트는 65,536(2^16)개의 조합밖에 만들어내지 못하기 때문에 현존하는 기호를 모두 표현하기에 충분하지 않다. 이를 극복하기 위해 사용 빈도가 낮은 기호는 '서로게이트 쌍(surrogate pair)'라고 불리는 2바이트 글자들의 쌍을 사용해 인코딩한다.

```jsx
console.log( '𝒳'.length ); // 2, 수학에서 쓰이는 대문자 X
console.log( '😂'.length ); // 2, 웃으면서 눈물 흘리는 얼굴을 나타내는 이모티콘
console.log( '𩷶'.length ); // 2, 사용 빈도가 낮은 중국어(상형문자)
```

서로게이트 쌍을 사용해 인코딩한 기호의 길이는 `2`이다.

자바스크립트가 만들어졌을 당시엔 서로게이트 쌍은 존재하지 않았기 때문에 자바스크립트는 서로게이트 쌍으로 표현한 기호를 제대로 처리하지 못한다.

String.fromCodePoint와 String.codePointAt은 명세서에 추가된 지 얼마 안된 메서드로 서로게이트 쌍을 제대로 처리할 수 있는 몇 안되는 메서드이다.

```jsx
console.log('𝒳'[0]); // 이상한 기호가 출력
console.log('𝒳'[1]); // 서로게이트 쌍의 일부가 출력
```

서로게이트 쌍을 구성하는 글자들은 붙어있을 때만 의미가 있다. 따라서 위 예시를 실행하면 의미 없는 기호가 출력된다.

기술적으로 서로게이트 쌍은 서로게이트 쌍에 대응하는 코드를 사용해 감지할 수 있다. 글자의 코드가 `0xd800..0xdbff`사이에 있으면 이 코드는 서로게이트 쌍을 구성하는 첫 번째 글자를 나타낸다는 것을 알 수 있다. 이 경우 서로게이트 쌍을 구성하는 두 번째 글자의 코드는 반드시 `0xdc00...0xdfff`사이에 있어야 한다. 범위 `0xd800...0xdbff`와 `0xdc00...0xdfff`는 표준에서 서로게이트 쌍을 위해 일부러 비워둔 코드이다.

### 발음 구별 기호와 유니코드 정규화

여러 언어에서 베이스가 되는 글자 위나 아래에 발음 구별 기호라 불리는 기호를 붙여 글자를 만든다.

`a`를 베이스 글자로,  `àáâäãåā`를 만드는 것 처럼 이런 '합성' 글자 대부분은 UTF-16테이블에서 독자적인 코드를 갖는다. 그런데 모든 합성 글자에 코드가 부여되지는 않는다. 조합 가능한 글자의 수가 너무 많기 때문이다.

임의의 조합을 지원하기 위해 UTF-16에선 몇 개의 유니코드 문자를 남겨두었다. 베이스 글자 뒤에 하나 혹은 여러개의 유니코드 문자를 붙여 베이스 글자를 꾸밀 수 있도록 말이다.

이를 이용하면 베이스 글자 `S`뒤에 윗 점을 나타내는 유니코드 문자(`\u0307`)를 붙여 `Ṡ`를 만들 수 있다.

```jsx
console.log('S\u0307'); // Ṡ
console.log('S\u0307\u0323'); // Ṩ
```

발음 구별 기호를 하나 붙인 상태에서 추가 발음 구별 기호가 필요한 경우에도 문제가 없다. 필요한 기호의 유니코드 문자를 붙여주기만 하면 된다.

이런 방식은 엄청난 유연성을 제공하는데, 단점도 있다. 눈으로 봤을 때는 같은 글자인데 유니코드 조합이 다른 경우가 생긴다.

```jsx
const s1 = 'S\u0307\u0323'; // Ṩ, S + 윗 점 + 아랫 점
const s1 = 'S\u0323\u0307'; // Ṩ, S + 아랫 점 + 윗 점

console.log(s1 === s2); // false
```

이런 문제를 해결하려면 유니코드 정규화라 불리는 알고리즘을 사용해 각 문자열을 동일한 형태로 정규화 해야하는데 관련 메서드로는 `str.normalize()`에 구현되어 있다.

## 문자열 메서드

### padStart / padEnd

ES2017에 추가된 스펙으로 문자열이 주어진 길이에 도달하도록 현재 문자열을 주어진 문자열로 채워준다.

```jsx
// str.padStart(targetLength [, padString]);
// str.padEnd(targetLength [, padString]);

const str = '200';

console.log(str.padStart(5, '0')); // '00200'
console.log(str.padEnd(5, '0')); // '20000'
```

첫 번째 매개변수는 목표 문자열의 길이, 두 번째 매개변수는 현재 문자열에서 채워넣을 문자열을 넣으면 된다. 기본값은 `' '`이며 선택사항이다.

`padStart`는 앞쪽에서, `padEnd`는 뒷쪽에서 문자열이 채워진다.

### startsWith / endsWith

ES2015에 추가된 스펙으로 문자열이 특정 문자열로 시작하거나 끝나는지 여부를 알 수 있다. 이 방법은 대소문자를 구분한다.

```jsx
// str.startWith(searchString [, length]);
// str.endWith(searchString [, length]);

const str = 'Cats are the best!';

console.log(str.endsWith('best', 17)); // true
console.log(str.startsWith('ats', 1)); // true
```

첫 번째 매개변수로 시작지점과 끝에서 검색할 문자열을 받고 두 번째 매기변수로 탐색할 위치, 검색할 문자열의 길이를 받는다. 두 번째 매개변수는 선택 사항이다.

반환값은 주어진 문자가 문자열 길이의 시작지점이나 끝에서 발견되면 `true`, 그렇지 않으면 `false`를 반환한다.

### includes

ES2015에 추가된 스펙으로 문자열에 다른 문자열이 포함되는지여부를 알 수 있다. 이 방법은 대소문자를 구분한다.

```jsx
// str.includes ( searchString [, position])

'Hello World!'.includes('world'); // true
```

첫 번째 매개변수로 검색할 문자열을 받고 두 번째 매개변수는 검색을 시작할 문자열 내 위치를 받는다. 두 번째 매개변수는 선택 사항이다.

반환값은 주어진 문자열 내에서 검색 문자열이 발견되면 `true`, 그렇지 않으면 `false`를 반환한다.

### repeat

ES2015에 추가된 스펙으로 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환한다.

```jsx
// str.repeat(count);

const str = 'hello ';

console.log(str.repeat(3)); // 'hello hello hello '
```

매개 변수로 문자열을 반복할 횟수를 받는다. (양의 정수)

반환 값은 현재 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환한다.

### 참고

[JAVASCRIPT.INFO - 문자열](https://ko.javascript.info/string)

[Mozilla - Javascript](https://developer.mozilla.org/ko/docs/Web/JavaScript)